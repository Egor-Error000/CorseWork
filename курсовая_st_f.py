# -*- coding: utf-8 -*-
"""КУРСОВАЯ_ST_f.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GFlegtTJbYN7CpBvHyhXd0M9yh2RhYku

#Подключение необходимых библиотек
"""

import numpy as np
import pandas as pd
import time
!pip install plotly
import scipy as Si
from numpy import linalg as LA
from scipy.integrate import tplquad , nquad , quad
import matplotlib.pyplot as plt
from scipy.constants import pi
from numba import jit, float64 , njit , types, prange
from joblib import Parallel, delayed
from scipy.integrate import odeint
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import matplotlib.colors as mcolors
from scipy.integrate import quad
from scipy.interpolate import interpn
import torch
import torch.nn as nn
import torch.optim as optim
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from scipy.integrate import DOP853 , RK45 , RK23
import time as Time
print("END")

"""# Функции для расчёта компонент

Общая часть радиальной и угловой компонент
"""

@jit(nopython=True, fastmath=True)
def d_Hct_componenT(f ,Rj, Rpc, Zk):
  objection_radius = Rpc**2 + Rj**2 + Zk**2
  objection_k = 2 * (Rj) * Rpc

  A = np.sin(f)* np.sqrt(objection_radius - objection_k * np.cos(f))
  B = np.sin(f) *  Rpc * np.cos(f) * np.log( Rj - Rpc * np.cos(f) + np.sqrt(objection_radius - objection_k* np.cos(f) ))
  return A + B

@jit(nopython=True, fastmath=True)
def d_Hcr_componenT(f ,Rj, Rpc, Zk):
  objection_radius = Rpc**2 + Rj**2 + Zk**2
  objection_k = 2 * (Rj) * Rpc

  A = np.cos(f)* np.sqrt(objection_radius - objection_k * np.cos(f))
  B = np.cos(f) *  Rpc * np.cos(f) * np.log( Rj - Rpc * np.cos(f) + np.sqrt(objection_radius - objection_k* np.cos(f) ))
  return A + B

"""_

Радиальная компонента
"""

@jit(nopython=True,fastmath=True)
# Определение функции Hcr с шестью параметрами: R, a, b, f, Rpc, Zpc
def Hcr(f, R, a, b,  Rpc, Zpc):
  # Использование функции d_Hcr_t для вычисления четырех значений
  # с разными комбинациями (R-a, R+a, Zpc-b, Zpc+b)

  A = d_Hcr_componenT(f,R - a, Rpc, Zpc + b) +  d_Hcr_componenT(f , R + a, Rpc, Zpc - b) # с разными знаками
  B = d_Hcr_componenT(f,R - a, Rpc, Zpc - b) +  d_Hcr_componenT(f , R + a, Rpc, Zpc + b) # с одинаковыми знаками

  return  A - B

"""_

Тангенсальная компонента
"""

@jit(nopython=True,fastmath=True)
# Определение функции Hcr с шестью параметрами: R, a, b, f, Rpc, Zpc
def Hct(f, R, a, b,  Rpc, Zpc):
  # Использование функции d_Hcr_t для вычисления четырех значений
  # с разными комбинациями (R-a, R+a, Zpc-b, Zpc+b)

  A = d_Hct_componenT(f,R - a, Rpc, Zpc + b) +  d_Hct_componenT(f , R + a, Rpc, Zpc - b) # с разными знаками
  B = d_Hct_componenT(f,R - a, Rpc, Zpc - b) +  d_Hct_componenT(f , R + a, Rpc, Zpc + b) # с одинаковыми знаками

  return  A - B

"""_

Компонента по оси Z
"""

@jit(nopython=True,fastmath=True)
def d_Hcz(Rj, Rpc, Zk, f):
  # Вычисление расстояния r по формуле
  F = Rj - Rpc * np.cos(f)
  r = np.sqrt(Rpc**2 + Rj**2 + Zk**2 - 2 * Rj * Rpc * np.cos(f))
  # Вычисление компонентов
  if (Rpc == 0) or (np.sin(f) == 0) or (r == 0):
    return -Zk * np.log(F + r)
  else:
    return -Zk * np.log(F + r) + \
          -Rpc * np.cos(f) * np.log(-Zk + r) + \
           Rpc * np.sin(f) * np.arctan((Zk * F) / \
                                   (Rpc * np.sin(f) * r))

"""![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABP0AAADhCAYAAACz+MCeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAJoYSURBVHhe7P0PfFNXfif8fzxN5hFbMjU7sJWeNQ2ahilyQzt2QxqpgVlEmb6Ql7TIP5hX8IYpyGE2scMzYIWdiRXaJjbpgATbxE6eIQiehJ9NB9biV6jFTliUpjASLaxFBx5fOjARUzwrtcPEKvFrrcwwc3/n/pF9JUu2bAwY83nzEta9urr33HPOvdL96pxzywYHB+WbN2/ixo0buHLlCrKWLFmiPyMiIiIiIiIiIqJ7yaf0v0RERERERERERDRNMOhHREREREREREQ0zTDoR0RERERERERENM0w6EdERERERERERDTNMOhHREREREREREQ0zTDoR0RERERERERENM0w6EdERERERERERDTNMOhHREREREREREQ0zTDoR0RERERERERENM0w6EdERERERERERDTNMOhHREREREREREQ0zTDoR0RERETTUmxnGcrKhh+BM/oLRERERPcBBv2IiIiI7qa+EOoNgamhx86YvsDUkR9E0x71CPXpC0wx9hdlyDG/PkVERER0f2HQj4iIiOhuqnBjrywjukOfhgdd12TIL9r16alDDaJd6xIp1O2IQpb3wl2hT09FTzhw58N+KYQ26EHRKRi8JSIiovsDg35EREREU4oNlqkcRDPwzLPqz8ZjOgXEiu1LAon9+lMpKZYiIiIiuvMY9CMiIiK6nbLdd9ni6z5iR5MsQ1Ye+9ww63OJiIiI7iQG/YiIiIhug6Hx7+bWIqjPmxSFxgA0BBRzx90LIHS43jCdfzOLGAKG13IfAfFqic4Ect4bOJyXxmz61LRbUJttBbfVob3uey1n+Xrx/uF0GdKRtx1t2fx2dPn75IBXf0WT97qatkLzho0Yy1B5vdi+7Hw7d10bQjkt/UaOi2gYEzGvbHPzQTzy1kVEREQ0Ggb9iIiIiG4Ddfw7OTq548kpQS81iKiP+yfLSB7y6AEnLTimbFedp/IijJbh5ZQ59mwQTQl0aQExf0xb19C4guu7kJSbUPKogk805Yz15z0OtCit3LLzRPrUYKM6fmESXeuVmYI6JqBYruUbYv5wXgXXJOAYugGHF1Hx3pQSvLSrqUVUeY+e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)"""

@jit(nopython=True,fastmath=True)
# Определение функции Hcz с пятью параметрами: f, R, a, b, Rpc, Zpc
def Hcz(f, R, a, b, Rpc, Zpc):
  # Использование функции d_Hcz для вычисления четырех значений
  # с разными комбинациями (R-a, R+a, Zpc-b, Zpc+b)
  A = d_Hcz(R - a, Rpc, Zpc + b, f) +d_Hcz(R + a, Rpc, Zpc - b, f)
  B = d_Hcz(R - a, Rpc, Zpc - b, f) +d_Hcz(R + a, Rpc, Zpc + b, f)
  return A - B

"""# Задание параметров"""

R, a = 10, 2 # см
b = 20        # см
J = 0.65e3        # СГС*ед
fpc=2.3        # рад



Const=J/(4*np.pi)

print(Const)

"""# Создание сетки"""

f_lim = [0-fpc, 2 * pi-fpc]
Rpc=1
Zpc=0.01

# Определение функции H_full_many с шестью параметрами: R, a, b, Rpc_, f_lim, Zpc_
def H_full_many(R, a, b, Rpc_, f_lim, Zpc_):

  # Вычисление интегралов для Hcr
  Hr, Hr_error = np.array([quad(Hcr, f_lim[0], f_lim[1], args=(R, a, b, Rpc, Zpc)) for Rpc in Rpc_])


  # Вычисление интегралов для Hcz
  Hz, Hz_error = np.array([quad(Hcz, f_lim[0], f_lim[1], args=(R, a, b, Rpc, Zpc),points=np.linspace(f_lim[0], f_lim[1], num_points)) for Zpc in Zpc_])

  # Возврат массива, содержащего значения Hr, Ht и Hz
  return np.array([ Hr , Hz  ])

Zpc_value=np.linspace(-1.4*b,1.4*b, 1000)
Rpc_value=np.linspace(0 , R-a, 200)

Zpc_exp = np.linspace(-1.8*b,1.8*b, 8000)
Rpc_exp = np.linspace(-1e-10  , R-a*(1+1e-10), 8000)

Rpc_mass = Rpc_exp
Zpc_mass = Zpc_exp
# Создание массивов для хранения результатов и ошибок
results_r = np.zeros((len(Rpc_mass), len(Zpc_mass)))
results_z = np.zeros((len(Rpc_mass), len(Zpc_mass)))


Points=[]

# Цикл по всем значениям Rpc_setka и Zpc_setka
for i, Rpc in enumerate(Rpc_mass):
    for j, Zpc in enumerate(Zpc_mass):

        # Вычисляем результат и ошибку для Hr с помощью quad
        result_r, error_r = np.array(quad(Hcr, f_lim[0], f_lim[1], args=(R, a, b, Rpc, Zpc)))
        results_r[i, j] = result_r  # Сохраняем результат в массив
        #errors_r[i, j] = error_r  # Сохраняем ошибку в массив

        # Вычисляем результат и ошибку для Hz с помощью quad
        result_z, error_z = np.array(quad(Hcz, f_lim[0], f_lim[1], args=(R, a, b, Rpc, Zpc), limit=5000))
        results_z[i, j] = result_z  # Сохраняем результат в массив
        #errors_z[i, j] = error_z  # Сохраняем ошибку в массив

print(results_r.shape)

# Сохраняем матрицу в файл
np.save('result_r(8000x8000).npy', results_r)
np.save('result_z(8000x8000).npy', results_z)

from scipy import interpolate

# Предполагая, что Rpc_mass и Zpc_mass - это массивы координат Rpc и Zpc
x_grid = Rpc_mass
y_grid = Zpc_mass
r_values = results_r  # Массив результатов Hr
z_values = results_z  # Массив результатов Hz

# Создание интерполяционной функции для Hr
interp_func_R = interpolate.RectBivariateSpline(x_grid, y_grid, r_values)


# Создание интерполяционной функции для Hz
interp_func_Z = interpolate.RectBivariateSpline(x_grid, y_grid, z_values)

# Точка, для которой вы хотите выполнить интерполяцию
R_query = 1.5  # Пример координаты Rpc
Z_query = 2.5  # Пример координаты Zpc

# Вычисление интерполированных значений
interpolated_value_R = interp_func_R.ev(R_query, Z_query)
interpolated_value_Z = interp_func_Z.ev(R_query, Z_query)



print("Интерполированное значение в точке ({}, {}) для results_r: {}".format(R_query, Z_query, interpolated_value_R))
print("Интерполированное значение в точке ({}, {}) для results_z: {}".format(R_query, Z_query, interpolated_value_Z))

print(r_values)

has_nan = np.isnan(z_values)

# Вывод результата
if np.any(has_nan):
    print("В массиве есть значения nan.")
else:
    print("В массиве нет значений nan.")

count_nan_r = np.sum(np.isnan(r_values))
count_nan_z = np.sum(np.isnan(r_values))

print("Количество значений nan в массиве:", count_nan_r)

print("Количество значений nan в массиве:", count_nan_z)

data=z_values
nan_indices = np.argwhere(np.isnan(data))

if len(nan_indices) > 0:
    # Проходимся по каждому индексу с nan
    for nan_index in nan_indices:
        row, col = nan_index

        # Выбираем ближайшие три числа слева и справа от nan вдоль каждой оси массива
        nearest_values_left = data[max(0, row - 3):row, col]
        nearest_values_right = data[row + 1:min(row + 4, data.shape[0]), col]

        print(f"Для nan в позиции ({row}, {col}):")
        print("Ближайшие три числа слева:", nearest_values_left)
        print("Ближайшие три числа справа:", nearest_values_right)
else:
    print("В массиве нет значений nan.")

print(Rpc_exp[0])

print(z_values)

Hr_v=[]
Hz_v=[]

Rpc_exp=1
for Zpc in Zpc_value:
  Hr_v.append(Const*interp_func_R.ev(Rpc_exp, Zpc))
  Hz_v.append(Const*interp_func_Z.ev(Rpc_exp, Zpc))

print(Hr_v)

print(Hz_v)

plt.figure(figsize=(10, 6))
plt.plot(Zpc_value,Hr_v)
plt.plot(Zpc_value,Hz_v)
plt.xlabel('Zpc')
plt.ylabel('Field Value')
plt.title('Interpolated Field Values vs Zpc_combined')
plt.legend()
plt.grid(True)
plt.show()

"""Моя реализация"""

@jit(parallel=True, fastmath=True,forceobj=True)
def BIM(x_grid, y_grid, field_grid, x, y):
    """
    Bilinear interpolation function for 2D grid.

    Parameters:
        x_grid (numpy.ndarray): 1D array of x-coordinates.
        y_grid (numpy.ndarray): 1D array of y-coordinates.
        field_grid (numpy.ndarray): 2D grid representing the field.
        x (float or numpy.ndarray): x-coordinate or array of x-coordinates of the points to interpolate.
        y (float or numpy.ndarray): y-coordinate or array of y-coordinates of the points to interpolate.

    Returns:
        interpolated_value (float or numpy.ndarray): Interpolated value at point (x, y) or array of interpolated values.
    """
    if isinstance(x, float) or isinstance(x, int):
        x = np.array([x])
    if isinstance(y, float) or isinstance(y, int):
        y = np.array([y])

    interpolated_values = np.zeros(x.shape, dtype=np.float64)

    # Поиск индексов с использованием поиска индексов в массивах x и y
    x_indices = np.searchsorted(x_grid, x) - 1
    y_indices = np.searchsorted(y_grid, y) - 1

    # Проверка на выход за границы сетки
    out_of_bounds = (x_indices < 0) | (x_indices >= len(x_grid) - 1) | (y_indices < 0) | (y_indices >= len(y_grid) - 1)
    x_indices[out_of_bounds] = 0
    y_indices[out_of_bounds] = 0

    # Извлечение значений сетки
    x0 = x_grid[x_indices]
    x1 = x_grid[x_indices + 1]
    y0 = y_grid[y_indices]
    y1 = y_grid[y_indices + 1]

    Q11 = field_grid[x_indices, y_indices]
    Q21 = field_grid[x_indices + 1, y_indices]
    Q12 = field_grid[x_indices, y_indices + 1]
    Q22 = field_grid[x_indices + 1, y_indices + 1]

    # Расчет коэффициентов
    R1 = ((x1 - x) * Q11 + (x - x0) * Q21) / (x1 - x0)
    R2 = ((x1 - x) * Q12 + (x - x0) * Q22) / (x1 - x0)

    # Интерполяция
    interpolated_values = ((y1 - y) * R1 + (y - y0) * R2) / (y1 - y0)

    # Замена значений вне границы сетки на np.nan
    interpolated_values[out_of_bounds] = np.nan

    if len(interpolated_values) == 1:
        return interpolated_values[0]
    return interpolated_values

@jit(parallel=True, fastmath=True,nopython=True)
def BIM_Speed(x_grid, y_grid, field_grid, x, y):
    """
    Bilinear interpolation function for 2D grid.

    Parameters:
        x_grid (numpy.ndarray): 1D array of x-coordinates.
        y_grid (numpy.ndarray): 1D array of y-coordinates.
        field_grid (numpy.ndarray): 2D grid representing the field.
        x (float or numpy.ndarray): x-coordinate or array of x-coordinates of the points to interpolate.
        y (float or numpy.ndarray): y-coordinate or array of y-coordinates of the points to interpolate.

    Returns:
        interpolated_value (float or numpy.ndarray): Interpolated value at point (x, y) or array of interpolated values.
    """
    if isinstance(x, float) or isinstance(x, int):
        x = np.array([x])
    if isinstance(y, float) or isinstance(y, int):
        y = np.array([y])


    # Поиск индексов с использованием поиска индексов в массивах x и y
    x_indices = np.searchsorted(x_grid, x) - 1
    y_indices = np.searchsorted(y_grid, y) - 1

    # Проверка на выход за границы сетки
    out_of_bounds = (x_indices < 0) | (x_indices >= len(x_grid) - 1) | (y_indices < 0) | (y_indices >= len(y_grid) - 1)
    x_indices[out_of_bounds] = 0
    y_indices[out_of_bounds] = 0

    # Извлечение значений сетки
    x0 = x_grid[x_indices]
    x1 = x_grid[x_indices + 1]
    y0 = y_grid[y_indices]
    y1 = y_grid[y_indices + 1]

    # Расчет коэффициентов
    R1 = np.zeros(x.shape, dtype=np.float64)
    R2 = np.zeros(x.shape, dtype=np.float64)
    for i in prange(len(x)):
        R1[i] = ((x1[i] - x[i]) * field_grid[x_indices[i], y_indices[i]] + (x[i] - x0[i]) * field_grid[x_indices[i] + 1, y_indices[i]]) / (x1[i] - x0[i])
        R2[i] = ((x1[i] - x[i]) * field_grid[x_indices[i], y_indices[i] + 1] + (x[i] - x0[i]) * field_grid[x_indices[i] + 1, y_indices[i] + 1]) / (x1[i] - x0[i])

    # Интерполяция
    interpolated_values = np.zeros(x.shape, dtype=np.float64)
    for i in prange(len(x)):
        interpolated_values[i] = ((y1[i] - y[i]) * R1[i] + (y[i] - y0[i]) * R2[i]) / (y1[i] - y0[i])

    # Замена значений вне границы сетки на np.nan
    for i in prange(len(interpolated_values)):
        if out_of_bounds[i]:
            interpolated_values[i] = np.nan


    return interpolated_values

@jit(parallel=True, fastmath=True,forceobj=True)
def bilinear_interpolation(x_grid, y_grid, field_grid, x, y):
    """
    Bilinear interpolation function for 2D grid.

    Parameters:
        x_grid (numpy.ndarray): 1D array of x-coordinates.
        y_grid (numpy.ndarray): 1D array of y-coordinates.
        field_grid (numpy.ndarray): 2D grid representing the field.
        x (float): x-coordinate of the point to interpolate.
        y (float): y-coordinate of the point to interpolate.

    Returns:
        interpolated_value (float): Interpolated value at point (x, y).
    """
    if np.isnan(x) or np.isnan(y):
        return np.nan

    x_index = np.searchsorted(x_grid, x) - 1
    y_index = np.searchsorted(y_grid, y) - 1

    if x_index < 0 or x_index >= len(x_grid) - 1 or y_index < 0 or y_index >= len(y_grid) - 1:
        return np.nan

    x0 = x_grid[x_index]
    x1 = x_grid[x_index + 1]
    y0 = y_grid[y_index]
    y1 = y_grid[y_index + 1]

    Q11 = field_grid[x_index, y_index]
    Q21 = field_grid[x_index + 1, y_index]
    Q12 = field_grid[x_index, y_index + 1]
    Q22 = field_grid[x_index + 1, y_index + 1]

    R1 = ((x1 - x) * Q11 + (x - x0) * Q21) / (x1 - x0)
    R2 = ((x1 - x) * Q12 + (x - x0) * Q22) / (x1 - x0)

    interpolated_value = ((y1 - y) * R1 + (y - y0) * R2) / (y1 - y0)

    return interpolated_value

import numpy as np

# Пример матриц координат сетки
x_grid = np.array([0, 1, 2, 3])
y_grid = np.array([0, 1, 2, 3])

# Пример матрицы значений поля в узлах сетки
field_grid = np.array([
    [10, 20, 30, 40],
    [50, 60, 70, 80],
    [90, 100, 110, 120],
    [130, 140, 150, 160]
])

# Пример координат точки, для которой нужно интерполировать значение поля
x = 1.5
y = 1.5

# Интерполируем значение поля в заданной точке
interpolated_value = bilinear_interpolation(x_grid, y_grid, field_grid, x, y)

# Вывод результата
print("Интерполированное значение поля в точке ({}, {}): {}".format(x, y, interpolated_value))

import numpy as np

# Пример данных сетки
x_grid = np.array([0, 1, 2, 3])
y_grid = np.array([0, 1, 2, 3])
field_grid = np.array([
    [10, 20, 30, 40],
    [50, 60, 70, 80],
    [90, 100, 110, 120],
    [130, 140, 150, 160]
])

# Пример координат, включающих np.nan
x_with_nan = np.array([0.1, 1, 9, 2.7])
y_with_nan = np.array([0.3, np.nan, 1, 2.3])

# Тестирование функции
result_with_nan = BIM(x_grid, y_grid, field_grid, x_with_nan, y_with_nan)

print("Результат интерполяции с np.nan:")
print(result_with_nan)

Rpc_my, Zpc_my= 1.5 , 2.5

interpolated_result_r = bilinear_interpolation(Rpc_mass, Zpc_mass, results_r, Rpc_my, Zpc_my)

print(interpolated_result_r)

Hr_v=[]
Hz_v=[]

Rpc_exp=1
for Zpc in Zpc_value:
  Hr_v.append(Const*bilinear_interpolation(Rpc_mass, Zpc_mass, results_r, Rpc_exp, Zpc))

plt.figure(figsize=(10, 6))
plt.plot(Zpc_value,Hr_v)
plt.xlabel('Zpc')
plt.ylabel('Field Value')
plt.title('Interpolated Field Values vs Zpc_combined')
plt.legend()
plt.grid(True)
plt.show()

"""# Функция полного поля"""

Zpc_exp = np.linspace(-1.8*b,1.8*b, 8000)
Rpc_exp = np.linspace(-1e-10  , R-a*(1+1e-10), 8000)

Rpc_mass = Rpc_exp
Zpc_mass = Zpc_exp

'''
# Сохраняем матрицу в файл
np.save('result_r (5000x5000) .npy', results_r)
np.save('result_z (5000x5000) .npy', results_z)
np.save('errors_r (5000x5000) .npy', errors_r)
np.save('errors_z (5000x5000) .npy', errors_z)
'''

# Сохраняем матрицу в файл
results_z=np.load('result_z(8000x8000).npy' )
results_r=np.load('result_r(8000x8000).npy' )

from scipy import interpolate

# Предполагая, что Rpc_mass и Zpc_mass - это массивы координат Rpc и Zpc
x_grid = Rpc_mass
y_grid = Zpc_mass
r_values = results_r  # Массив результатов Hr
z_values = results_z  # Массив результатов Hz

# Создание интерполяционной функции для Hr
interp_func_R = interpolate.RectBivariateSpline(x_grid, y_grid, r_values)

# Создание интерполяционной функции для Hz
interp_func_Z = interpolate.RectBivariateSpline(x_grid, y_grid, z_values)

"""Моя реализация"""

@jit(parallel=True, fastmath=True,nopython=True)
def BIM_Speed(x_grid, y_grid, field_grid, x, y):
    """
    Bilinear interpolation function for 2D grid.

    Parameters:
        x_grid (numpy.ndarray): 1D array of x-coordinates.
        y_grid (numpy.ndarray): 1D array of y-coordinates.
        field_grid (numpy.ndarray): 2D grid representing the field.
        x (float or numpy.ndarray): x-coordinate or array of x-coordinates of the points to interpolate.
        y (float or numpy.ndarray): y-coordinate or array of y-coordinates of the points to interpolate.

    Returns:
        interpolated_value (float or numpy.ndarray): Interpolated value at point (x, y) or array of interpolated values.
    """
    if isinstance(x, float) or isinstance(x, int):
        x = np.array([x])
    if isinstance(y, float) or isinstance(y, int):
        y = np.array([y])


    # Поиск индексов с использованием поиска индексов в массивах x и y
    x_indices = np.searchsorted(x_grid, x) - 1
    y_indices = np.searchsorted(y_grid, y) - 1

    # Проверка на выход за границы сетки
    out_of_bounds = (x_indices < 0) | (x_indices >= len(x_grid) - 1) | (y_indices < 0) | (y_indices >= len(y_grid) - 1)
    x_indices[out_of_bounds] = 0
    y_indices[out_of_bounds] = 0

    # Извлечение значений сетки
    x0 = x_grid[x_indices]
    x1 = x_grid[x_indices + 1]
    y0 = y_grid[y_indices]
    y1 = y_grid[y_indices + 1]

    # Расчет коэффициентов
    R1 = np.zeros(x.shape, dtype=np.float64)
    R2 = np.zeros(x.shape, dtype=np.float64)
    for i in prange(len(x)):
        R1[i] = ((x1[i] - x[i]) * field_grid[x_indices[i], y_indices[i]] + (x[i] - x0[i]) * field_grid[x_indices[i] + 1, y_indices[i]]) / (x1[i] - x0[i])
        R2[i] = ((x1[i] - x[i]) * field_grid[x_indices[i], y_indices[i] + 1] + (x[i] - x0[i]) * field_grid[x_indices[i] + 1, y_indices[i] + 1]) / (x1[i] - x0[i])

    # Интерполяция
    interpolated_values = np.zeros(x.shape, dtype=np.float64)
    for i in prange(len(x)):
        interpolated_values[i] = ((y1[i] - y[i]) * R1[i] + (y[i] - y0[i]) * R2[i]) / (y1[i] - y0[i])

    # Замена значений вне границы сетки на np.nan
    for i in prange(len(interpolated_values)):
        if out_of_bounds[i]:
            interpolated_values[i] = np.nan


    return interpolated_values

@jit(parallel=True, fastmath=True,nopython=True)
def BIM_Speed_notnan(x_grid, y_grid, field_grid, x, y):
    """
    Bilinear interpolation function for 2D grid.

    Parameters:
        x_grid (numpy.ndarray): 1D array of x-coordinates.
        y_grid (numpy.ndarray): 1D array of y-coordinates.
        field_grid (numpy.ndarray): 2D grid representing the field.
        x (float or numpy.ndarray): x-coordinate or array of x-coordinates of the points to interpolate.
        y (float or numpy.ndarray): y-coordinate or array of y-coordinates of the points to interpolate.

    Returns:
        interpolated_value (float or numpy.ndarray): Interpolated value at point (x, y) or array of interpolated values.
    """
    if isinstance(x, float) or isinstance(x, int):
        x = np.array([x])
    if isinstance(y, float) or isinstance(y, int):
        y = np.array([y])


    # Поиск индексов с использованием поиска индексов в массивах x и y
    x_indices = np.searchsorted(x_grid, x) - 1
    y_indices = np.searchsorted(y_grid, y) - 1

    # Проверка на выход за границы сетки
    out_of_bounds = (x_indices < 0) | (x_indices >= len(x_grid) - 1) | (y_indices < 0) | (y_indices >= len(y_grid) - 1)
    x_indices[out_of_bounds] = 0
    y_indices[out_of_bounds] = 0

    # Извлечение значений сетки
    x0 = x_grid[x_indices]
    x1 = x_grid[x_indices + 1]
    y0 = y_grid[y_indices]
    y1 = y_grid[y_indices + 1]

    # Расчет коэффициентов
    R1 = np.zeros(x.shape, dtype=np.float64)
    R2 = np.zeros(x.shape, dtype=np.float64)
    for i in prange(len(x)):
        R1[i] = ((x1[i] - x[i]) * field_grid[x_indices[i], y_indices[i]] + (x[i] - x0[i]) * field_grid[x_indices[i] + 1, y_indices[i]]) / (x1[i] - x0[i])
        R2[i] = ((x1[i] - x[i]) * field_grid[x_indices[i], y_indices[i] + 1] + (x[i] - x0[i]) * field_grid[x_indices[i] + 1, y_indices[i] + 1]) / (x1[i] - x0[i])

    # Интерполяция
    interpolated_values = np.zeros(x.shape, dtype=np.float64)
    for i in prange(len(x)):
        interpolated_values[i] = ((y1[i] - y[i]) * R1[i] + (y[i] - y0[i]) * R2[i]) / (y1[i] - y0[i])

    # Замена значений вне границы сетки на np.nan
    for i in prange(len(interpolated_values)):
        if out_of_bounds[i]:
            interpolated_values[i] = 0


    return interpolated_values

"""# Одиночная реализация"""

@jit(parallel=True, fastmath=True, forceobj=True)
def H_full_parallel(Const: float64, R: float64, a: float64, b: float64, r_pc: np.array):
    H_results = np.zeros((len(r_pc), 3))

    for i in prange(len(r_pc)):
        X, Y, Z = r_pc[i]
        L = pow(X**2 + Y**2, 0.5)

        if L == 0:
            Rpc, sin_fpc , cos_fpc, Zpc = 0,0, 0, Z
        else:
            Rpc, sin_fpc , cos_fpc, Zpc = L, Y/L, X/L, Z

        f_0 = 0
        f_end = 2 * np.pi

        Hr, Hr_error = Const * np.array(quad(Hcr, f_0, f_end, args=(R, a, b, Rpc, Zpc)))
        Hz, Hz_error = Const * np.array(quad(Hcz, f_0, f_end, args=(R, a, b, Rpc, Zpc)))

        H_results[i] = np.array([Hr*cos_fpc, Hr*sin_fpc, Hz])

    return H_results

@jit(parallel=True, fastmath=True,forceobj=True)
def H_simple_setka(r_pc: np.array):



  X, Y, Z = r_pc.tolist()
  L = pow(X**2 + Y**2, 0.5)

  # Вычисление угловых координат Rpc, fpc, Zpc
  if L == 0:
    Rpc, sin_fi,cos_fi,Zpc = 0, 0, 0, Z
  else:
    Rpc, sin_fi,cos_fi, Zpc = L, Y/L ,X/L , Z


  Hr = Const*interp_func_R.ev(Rpc, Zpc)

  Hz = Const*interp_func_Z.ev(Rpc, Zpc)


  return np.array([Hr*cos_fi, Hr*sin_fi, Hz])

@jit(parallel=True, fastmath=True, forceobj=True)
def H_simple_setka_parallel( r_pc: np.array):
    result = np.zeros((len(r_pc), 3))

    for i in prange(len(r_pc)):
        X, Y, Z = r_pc[i].tolist()
        L = pow(X**2 + Y**2, 0.5)

        # Вычисление угловых координат Rpc, fpc, Zpc
        if L == 0:
            Rpc, sin_fpc, cos_fpc , Zpc = 0 , 0 , 0 , Z
        else:
            Rpc, sin_fpc, cos_fpc , Zpc = L, Y/L , X/L, Z

        Hr = Const*interp_func_R.ev(Rpc, Zpc)
        #Hr_error = interp_func_R_error.ev(Rpc, Zpc)

        Hz = Const*interp_func_Z.ev(Rpc, Zpc)
        #Hz_error = interp_func_Z_error.ev(Rpc, Zpc)

        result[i] = np.array([Hr*cos_fpc, Hr*sin_fpc, Hz])

    return result

@jit(nopython=True,parallel=True, fastmath=True)
def H_my_simple_setka( r_pc: np.array):

     # Преобразование r_pc в массивы X, Y, Z
     X, Y, Zpc_loc = r_pc.T
     nonzero_indices = []
     zero_indices = []
     # Вычисление L
     L = np.empty(len(r_pc))


     for i, r in enumerate(r_pc):
        x, y, z = r
        l = (x**2+y**2)**0.5
        L[i] = l
        if l != 0:
             nonzero_indices.append(i)
        else:
             zero_indices.append(i)

     # Интерполяция Rpc, fpc, Zpc
     loc_X = np.zeros_like(L)
     loc_Y = np.zeros_like(L)
     Rpc_loc=L

     for i in range(len(nonzero_indices)):
         index = nonzero_indices[i]
         loc_X[index] = X[index] / L[index]
         loc_Y[index] = Y[index] / L[index]

     for i in range(len(zero_indices)):
         index = zero_indices[i]
         loc_X[index] = 0
         loc_Y[index] = 0



     Hr = Const*BIM_Speed(Rpc_mass, Zpc_mass, results_r, Rpc_loc, Zpc_loc)
     Hz = Const*BIM_Speed(Rpc_mass, Zpc_mass, results_z, Rpc_loc, Zpc_loc)

     result = np.stack((Hr * loc_X, Hr * loc_Y, Hz)).T

     return result

@jit(nopython=True,parallel=True, fastmath=True)
def H_my_simple_setka_notnan( r_pc: np.array):

     # Преобразование r_pc в массивы X, Y, Z
     X, Y, Zpc_loc = r_pc.T
     nonzero_indices = []
     zero_indices = []
     # Вычисление L
     L = np.empty(len(r_pc))


     for i, r in enumerate(r_pc):
        x, y, z = r
        l = (x**2+y**2)**0.5
        L[i] = l
        if l != 0:
             nonzero_indices.append(i)
        else:
             zero_indices.append(i)

     # Интерполяция Rpc, fpc, Zpc
     loc_X = np.zeros_like(L)
     loc_Y = np.zeros_like(L)
     Rpc_loc=L

     for i in range(len(nonzero_indices)):
         index = nonzero_indices[i]
         loc_X[index] = X[index] / L[index]
         loc_Y[index] = Y[index] / L[index]

     for i in range(len(zero_indices)):
         index = zero_indices[i]
         loc_X[index] = 0
         loc_Y[index] = 0


     Hr = Const*BIM_Speed_notnan(Rpc_mass, Zpc_mass, results_r, Rpc_loc, Zpc_loc)
     Hz = Const*BIM_Speed_notnan(Rpc_mass, Zpc_mass, results_z, Rpc_loc, Zpc_loc)


     result = np.stack((Hr * loc_X, Hr * loc_Y, Hz)).T

     return result

"""# Задача для пучка электронов"""

# Класс, представляющий дифференциальное уравнение
class IDE_many_particuls:
    def __init__(self, Function):
        self.Function = Function  # Функция, описывающая уравнение

    # Задание параметров ДУ
    def set_parameters(self, state, t0, t_end, h , K):
        """
        Установка параметров для решения уравнения.

        Parameters:
        - state: Начальные условия
        - t_end: Время окончания
        - h: Шаг интегрирования
        """
        self.state = state
        self.t0 = t0
        self.t_end = t_end
        self.h = h
        self.k=K
        self.L=len(state[0])

    # Задача ДУ
    def IDE_Function(self, t,state ):
        """
        Функция, вычисляющая производные состояния в соответствии с уравнением.

        Parameters:
        - t: Время
        - state: Текущее состояние

        Returns:
        - result: Массив производных состояний
        """
        result = self.Function(t , state)
        return result

     #

    # Метод Рунге-Кутты 4 для расчёта ДУ
    @jit(parallel=True, fastmath=True,forceobj=True)
    def runge_kutta(self):
      state = self.state
      time_points = np.linspace(self.t0, self.t_end, (int((self.t_end - self.t0) / self.h) + 1))
      positions = np.empty((len(time_points), state.shape[0],state.shape[1]))
      positions[:,:,:]=np.nan
      positions[0] = state # Используем список вместо массива
      n=0
      t = self.t0
      for i in range(1, len(time_points)):
        k1 = self.h * np.array(self.IDE_Function(t, state))
        k2 = self.h * np.array(self.IDE_Function(t + 0.5 * self.h, state + 0.5 * k1))
        k3 = self.h * np.array(self.IDE_Function(t + 0.5 * self.h, state + 0.5 * k2))
        k4 = self.h * np.array(self.IDE_Function(t + self.h, state + k3))


        state += (k1 + 2*k2 + 2*k3 + k4) / 6
        '''
        print(f"{i}-ая итерация",state)
        print(f"{i}-ый ",state.shape)
        print(" ")
        '''
        t += self.h
        if np.all(np.isnan(state)):
           break
        positions[i] = state


      return time_points, positions  # Преобразуем список в массив для совместимости с остальным кодом

    # Расчёт ДУ
    @jit(parallel=True, fastmath=True,forceobj=True)
    def calculete_parametrs(self):
        time_points, positions = self.runge_kutta()

        positions_array = positions
        positions_array_sort = np.transpose(positions_array, (1, 0, 2))
        x, v = np.split(positions_array_sort, 2)

        # Условие для выбора значений из x и v
        condition = ~((x[:,:, 2] >= A) & (x[:,:, 2] <= B) & ((x[:,:, 0]**2 + x[:,:, 1]**2) < C**2))

        # Заполнение X и V значениями NaN для невыполняющих условие значений
        x[condition] = np.nan
        v[condition] = np.nan

        self.x = x
        self.v = v

        self.time_points = time_points
        # Создание маски, содержащей значения True для векторов, не содержащих NaN

        X = np.zeros((x.shape[0], x.shape[2]))
        V = np.zeros((x.shape[0], x.shape[2]))

        for i in range(x.shape[0]):
          # Найти индекс последнего элемента, не являющегося NaN
          idx = np.where(~np.isnan(LA.norm(x[i], axis=1)))[0][-1]
          idv = np.where(~np.isnan(LA.norm(v[i], axis=1)))[0][-1]
          idstate=min(idx,idv)
          X[i] = x[i, idstate]
          V[i] = v[i, idstate]

        print(self.x.shape)
        print("начальные параметры")
        print("X = ",self.x[:,0])
        print("V = ",self.v[:,0])

        print("конечные параметры")
        print("X = ",np.array(X))
        print("V = ",np.array(V))
        return X , V

    # Вывод результатов расчёта
    def print_result(self,N,K):
      X = self.x
      V = self.v


      for i in range(self.k):
        print("------------------------------------------")
        print(f"Координаты и скорости {i+1}-ой частицы ")
        x=X[i]
        v=V[i]
        print(x.shape)
        print(v.shape)
        for j in range(3):
          print(f"{j+1}-ая компонента координаты")
          print(x.T[j])
          print(" ")
          print(f"{j+1}-ая компонента скорости")
          print(v.T[j])
          print(" ")
        print("  ")
        print("  ")

    # Функция отображения компонент поля
    def plot_solution_2d(self, text_mas):
      x = np.transpose(self.x, (2, 0, 1))
      v = np.transpose(self.v, (2, 0, 1))
      print(x.shape)
      print(v.shape)
      for k in range(3):
        print(x[k].shape)
        figx = make_subplots(rows=1, cols=1)
        for i in range(self.k):
            figx.add_trace(go.Scatter(x=self.time_points, y=x[k][i], mode='lines', name=f"R{k+1} {i+1}"))
        self.plt_markers_P(k, figx,"координата")
        figx.update_layout(title_text='Interactive 2D Solution Plot', showlegend=False)

        fig = make_subplots(rows=1, cols=1)
        for i in range(self.k):
            fig.add_trace(go.Scatter(x=self.time_points, y=v[k][i], mode='lines', name=f"V{k+1} {i+1}"))
        self.plt_markers_P(k, fig,"скорость")
        fig.update_layout(title_text='Interactive 2D Solution Plot', showlegend=False)


        Fig = make_subplots(rows=1, cols=1)
        for i in range(self.k):
            Fig.add_trace(go.Scatter(x=x[k][i], y=v[k][i], mode='lines', name=f' v/x-{i+1}'))

        self.plt_markers_F(k, Fig)
        Fig.update_layout(title_text='Interactive 2D Solution Plot', showlegend=False)
      figx1 = make_subplots(rows=1, cols=1)
      for j in range(self.k):
        figx1.add_trace(go.Scatter(x=self.time_points, y=LA.norm(self.v[j],axis=1), mode='lines', name=f"V{j}"))
      print(f'-----------------///---------------')
      print(f'  ')
      print(f'-----------------///---------------')
      figx1.update_layout(xaxis_title='время', yaxis_title="модуль скорости")
      figx1.update_layout(title=f'Зависимость от времени модуля скорости')

      figx1.update_layout(legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
      figx1.show()
      figx1.update_layout(title_text='ytyt', showlegend=False)


    # Функция отображения графика в пространстве
    def plot_solution_3d(self, text_mas):
      fig = make_subplots(rows=1, cols=1, specs=[[{'type': 'scatter3d'}]])
      x = np.transpose(self.x, (0, 2, 1))
      v = np.transpose(self.v, (0, 2, 1))
      for i in range(self.k):
        fig.add_trace(go.Scatter3d(x=x[i][0], y=x[i][1], z=x[i][2], mode='lines'))
      fig.update_layout(scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z'), scene_aspectmode='cube')
      fig.update_layout(title_text='Траектория', showlegend=False)
      fig.show()
      fig = make_subplots(rows=1, cols=1, specs=[[{'type': 'scatter3d'}]])
      for i in range(self.k):
        fig.add_trace(go.Scatter3d(x=v[i][0], y=v[i][1], z=v[i][2], mode='lines'))
      fig.update_layout(scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z'), scene_aspectmode='cube')
      fig.update_layout(title_text='Скорость', showlegend=False)
      fig.show()

    # оформление графика величин от времени
    def plt_markers_P(self, k, fig ,text):
       print(f'-----------------///---------------')
       print(f'  ')
       print(f'-----------------///---------------')
       fig.update_layout(xaxis_title='время', yaxis_title=text)
       fig.update_layout(title=f'Зависимость от времени {k+1}-ой {text}')

       fig.update_layout(legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
       fig.show()

    # оформление фазового портрета
    def plt_markers_F(self, k, fig):

      fig.update_layout(xaxis_title='координата', yaxis_title='скорость')
      fig.update_layout(title=f'Фазовый портрет {k+1}-ой координаты')

      fig.update_layout(legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
      fig.show()

# Класс, представляющий дифференциальное уравнение
class IDE_many_particuls_notnan:
    def __init__(self, Function):
        self.Function = Function  # Функция, описывающая уравнение

    # Задание параметров ДУ
    def set_parameters(self, state, t0, t_end, h , K):
        """
        Установка параметров для решения уравнения.

        Parameters:
        - state: Начальные условия
        - t_end: Время окончания
        - h: Шаг интегрирования
        """
        self.state = state
        self.t0 = t0
        self.t_end = t_end
        self.h = h
        self.k=K
        self.L=len(state[0])

    # Задача ДУ
    def IDE_Function(self, t,state ):
        """
        Функция, вычисляющая производные состояния в соответствии с уравнением.

        Parameters:
        - t: Время
        - state: Текущее состояние

        Returns:
        - result: Массив производных состояний
        """
        result = self.Function(t , state)
        return result

     #

    # Метод Рунге-Кутты 4 для расчёта ДУ
    @jit(parallel=True, fastmath=True,forceobj=True)
    def runge_kutta(self):
      state = self.state
      time_points = np.linspace(self.t0, self.t_end, (int((self.t_end - self.t0) / self.h) + 1))
      positions = np.empty((len(time_points), state.shape[0],state.shape[1]))

      positions[0] = state # Используем список вместо массива
      n=0
      t = self.t0
      for i in range(1, len(time_points)):
        k1 = self.h * np.array(self.IDE_Function(t, state))
        k2 = self.h * np.array(self.IDE_Function(t + 0.5 * self.h, state + 0.5 * k1))
        k3 = self.h * np.array(self.IDE_Function(t + 0.5 * self.h, state + 0.5 * k2))
        k4 = self.h * np.array(self.IDE_Function(t + self.h, state + k3))


        state += (k1 + 2*k2 + 2*k3 + k4) / 6
        t += self.h
        positions[i] = state


      return time_points, positions  # Преобразуем список в массив для совместимости с остальным кодом

    # Расчёт ДУ
    @jit(parallel=True, fastmath=True,forceobj=True)
    def calculete_parametrs(self):
        time_points, positions = self.runge_kutta()

        positions_array = positions
        positions_array_sort = np.transpose(positions_array, (1, 0, 2))
        x, v = np.split(positions_array_sort, 2)

        self.x = x
        self.v = v

        self.time_points = time_points

        print(self.x.shape)
        print("начальные параметры")
        print("X = ",np.transpose(x, (1, 0, 2))[0])
        print("V = ",np.transpose(v, (1, 0, 2))[0])

        print("конечные параметры")
        print("X = ",np.transpose(x, (1, 0, 2))[-1])
        print("V = ",np.transpose(v, (1, 0, 2))[-1])

        return np.transpose(x, (1, 0, 2))[-1] ,\
               np.transpose(v, (1, 0, 2))[-1]

    # Вывод результатов расчёта
    def print_result(self,N,K):
      X = self.x
      V = self.v



      for i in range(self.k):
        print("------------------------------------------")
        print(f"Координаты и скорости {i+1}-ой частицы ")
        x=X[i]
        v=V[i]
        print(x.shape)
        print(v.shape)
        for j in range(3):
          print(f"{j+1}-ая компонента координаты")
          print(x.T[j])
          print(" ")
          print(f"{j+1}-ая компонента скорости")
          print(v.T[j])
          print(" ")
        print("  ")
        print("  ")

    # Функция отображения компонент поля
    def plot_solution_2d(self, text_mas):
      x = np.transpose(self.x, (2, 0, 1))
      v = np.transpose(self.v, (2, 0, 1))
      print(x.shape)
      print(v.shape)

      def mins(x):
        if len(x)>0:
          return min(x)
        else:
          return -1

      def solenoid(fig):
        fig.add_trace(go.Scatter(x=T_00, y=R_sol, mode='lines', name="начало первого", line=dict(color="black")))
        fig.add_trace(go.Scatter(x=T_01, y=R_sol, mode='lines', name="конец первого",  line=dict(color="black")))
        fig.add_trace(go.Scatter(x=T_10, y=R_sol, mode='lines', name="начало второго", line=dict(color="black")))
        fig.add_trace(go.Scatter(x=T_11, y=R_sol, mode='lines', name="конец второго",  line=dict(color="black")))




      time_0s = self.time_points[  mins( np.where(self.x[:, :, 2] > -b)[1])       ]
      time_0e = self.time_points[  mins( np.where(self.x[:, :, 2] > b)[1])        ]
      time_1s = self.time_points[  mins( np.where(self.x[:, :, 2] > alfa*b-b)[1]) ]
      time_1e = self.time_points[  mins( np.where(self.x[:, :, 2] > alfa*b+b)[1]) ]

      T_00=[time_0s,time_0s]
      T_01=[time_0e,time_0e]
      T_10=[time_1s,time_1s]
      T_11=[time_1e,time_1e]

      R_sol=[-R+a,+R-a]

      def j(x):
        if len(x)>0:
          return min(x)
        else:
          return 0

      def solenoid(fig):
        fig.add_trace(go.Scatter(x=T_00, y=R_sol, mode='lines', name="начало первого", line=dict(color="black")))
        fig.add_trace(go.Scatter(x=T_01, y=R_sol, mode='lines', name="конец первого",  line=dict(color="black")))
        fig.add_trace(go.Scatter(x=T_10, y=R_sol, mode='lines', name="начало второго", line=dict(color="black")))
        fig.add_trace(go.Scatter(x=T_11, y=R_sol, mode='lines', name="конец второго",  line=dict(color="black")))



      for k in range(3):
        print(x[k].shape)
        figx = make_subplots(rows=1, cols=1)
        for i in range(self.k):
            figx.add_trace(go.Scatter(x=self.time_points, y=x[k][i], mode='lines', name=f"R{k+1} {i+1}"))

        solenoid(figx)

        self.plt_markers_P(k, figx,"координата")
        figx.update_layout(title_text='Interactive 2D Solution Plot', showlegend=False)

        fig = make_subplots(rows=1, cols=1)
        for i in range(self.k):
            fig.add_trace(go.Scatter(x=self.time_points, y=v[k][i], mode='lines', name=f"V{k+1} {i+1}"))

        #solenoid(fig)
        self.plt_markers_P(k, fig,"скорость")
        fig.update_layout(title_text='Interactive 2D Solution Plot', showlegend=False)


        Fig = make_subplots(rows=1, cols=1)
        for i in range(self.k):
            Fig.add_trace(go.Scatter(x=x[k][i], y=v[k][i], mode='lines', name=f' v/x-{i+1}'))

        self.plt_markers_F(k, Fig)
        Fig.update_layout(title_text='Interactive 2D Solution Plot', showlegend=False)
      figx1 = make_subplots(rows=1, cols=1)
      for j in range(self.k):
        figx1.add_trace(go.Scatter(x=self.time_points, y=LA.norm(self.v[j],axis=1), mode='lines', name=f"V{j}"))
      print(f'-----------------///---------------')
      print(f'  ')
      print(f'-----------------///---------------')
      figx1.update_layout(xaxis_title='время', yaxis_title="модуль скорости")
      figx1.update_layout(title=f'Зависимость от времени модуля скорости')

      figx1.update_layout(legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
      figx1.show()
      figx1.update_layout(title_text='ytyt', showlegend=False)


    # Функция отображения графика в пространстве
    def plot_solution_3d(self, text_mas):
      fig = make_subplots(rows=1, cols=1, specs=[[{'type': 'scatter3d'}]])
      x = np.transpose(self.x, (0, 2, 1))
      v = np.transpose(self.v, (0, 2, 1))
      for i in range(self.k):
        fig.add_trace(go.Scatter3d(x=x[i][0], y=x[i][1], z=x[i][2], mode='lines'))
      fig.update_layout(scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z'), scene_aspectmode='cube')
      fig.update_layout(title_text='Траектория', showlegend=False)
      fig.show()
      fig = make_subplots(rows=1, cols=1, specs=[[{'type': 'scatter3d'}]])
      for i in range(self.k):
        fig.add_trace(go.Scatter3d(x=v[i][0], y=v[i][1], z=v[i][2], mode='lines'))
      fig.update_layout(scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z'), scene_aspectmode='cube')
      fig.update_layout(title_text='Скорость', showlegend=False)
      fig.show()

    # оформление графика величин от времени
    def plt_markers_P(self, k, fig ,text):
       print(f'-----------------///---------------')
       print(f'  ')
       print(f'-----------------///---------------')
       fig.update_layout(xaxis_title='время', yaxis_title=text)
       fig.update_layout(title=f'Зависимость от времени {k+1}-ой {text}')

       fig.update_layout(legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
       fig.show()

    # оформление фазового портрета
    def plt_markers_F(self, k, fig):

      fig.update_layout(xaxis_title='координата', yaxis_title='скорость')
      fig.update_layout(title=f'Фазовый портрет {k+1}-ой координаты')

      fig.update_layout(legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
      fig.show()

@jit(parallel=True, fastmath=True,forceobj=True)
def newFunction(t, state):




    x = state[:len(state)//2]
    v = state[len(state)//2:]

    dxdt = v
    gamma = 1/(1-LA.norm(v)**2/c**2)
    gamma_dash = (gamma+gamma**3/c**2*LA.norm(v))


    F = calculate_force(x, Q)
    fl = beta*np.cross(v/c, H_full_parallel(Const, R, a, b, x)+H_full_parallel(Const, R, a, b, x-X0))
    dvdt = (q / m * fl + F/ m )/gamma_dash


    my_array = np.concatenate((dxdt,dvdt))


    return my_array

@jit(parallel=True, fastmath=True,forceobj=True)
def newFunctionA(t, state):

    x = state[:len(state)//2]
    v = state[len(state)//2:]


    dxdt = v

    gamma = 1/(1-LA.norm(v)**2/c**2)
    gamma_dash = (gamma+gamma**3/c**2*LA.norm(v))


    F = calculate_force(x, Q)
    fl = beta *np.cross(v/c, H_simple_setka_parallel(x)+H_simple_setka_parallel(x-X0))
    dvdt = (q / m * fl + -F[i]/ m )/gamma_dash
    my_array = np.concatenate((dxdt,dvdt))


    return my_array

@jit(parallel=True, fastmath=True,forceobj=True)
def newFunctionB(t, state):

    x = state[:len(state)//2]
    v = state[len(state)//2:]

    dxdt = v
    norm_V=LA.norm(v,axis=1)
    gamma=(1-norm_V**2/c**2)**0.5
    F = calculate_force(x, Q)
    fl = np.cross(v/c, H_my_simple_setka_notnan(x)+H_my_simple_setka_notnan(x-X0))
    dvdt = beta * q / m* np.multiply(fl.T, gamma).T + F / m
    my_array = np.concatenate((dxdt,dvdt))


    return my_array

def newFunctionC(t,state):

    x = state[:len(state)//2]
    v = state[len(state)//2:]

    dxdt=[]
    dvdt=[]
    F=calculate_force(x,Q)
    # Производная положения по времени - скорость
    for i in range(K):
      dxdt.append(v[i])
      # Производная скорости по времени - ускорение, определенное внешней силой
      dvdt.append( q / m * np.cross(v[i]/c, H_simple_setka(x[i])+H_simple_setka(x[i]-x0))+F[i]/ m )

    my_list=dxdt + dvdt

    my_array = np.array(my_list)


    return my_list

@jit(parallel=True, fastmath=True,forceobj=True)
def newFunctionD(t, state):

    x = state[:len(state)//2]
    v = state[len(state)//2:]

    X = np.zeros_like(x) * np.nan
    V = np.zeros_like(v) * np.nan


    # Условие для выбора значений из x и v
    condition = (x[:, 2] >= A) & (x[:, 2] <= B) & ((x[:, 0]**2 + x[:, 1]**2) < C**2)

    X[condition] = x[condition]
    V[condition] = v[condition]


    dxdt = V

    F = calculate_force(X, Q)
    H1 = H_my_simple_setka(X)
    H2 = H_my_simple_setka(X-X0)
    dvdt = q / m * np.cross(V/c, H1+H2) + F / m
    my_array = np.concatenate((dxdt,dvdt))


    return my_array

def rand(randomstate):
  return np.random.rand(randomstate)

def par(a, v):
    # Проекция каждого вектора a на соответствующий вектор v
    dot_product = np.sum(a * v, axis=1)
    norm_squared = np.sum(v * v, axis=1)
    projections = (dot_product / norm_squared)[:, np.newaxis] * v
    return projections

def per(a, v):
    # Вычисление перпендикулярной компоненты
    projections = par(a, v)
    perpendiculars = a - projections
    return perpendiculars

# Пример использования
fil = np.array([[3, 4, 5], [1, 2, 3], [0, 0, 1]])
v = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])

@jit(parallel=True, fastmath=True,forceobj=True)
def calculate_force(mas_coordinat, q):
    const = 1
    mas = np.array(mas_coordinat)
    l = len(mas_coordinat)
    F = np.zeros(mas.shape, dtype=np.float64)

    if l == 0:
        return F  # Возвращаем массив нулей, если mas_coordinat пустой

    for i, xi in enumerate(mas):
        idx_xi = np.where(np.all(mas == xi, axis=1))  # Находим индексы, где x=xi
        idnan_xi = np.where(np.isnan(LA.norm(mas, axis=1)))  # Находим индексы, где x=nan

        idsum = np.union1d(idx_xi, idnan_xi)
        ri = np.delete(xi-mas, idsum, axis=0)  # Исключаем xi из массива ri
        Ri = LA.norm(ri, axis=1)

        # Проверяем, остался ли массив ri пустым
        if len(ri) == 0:
            return F  # Возвращаем массив нулей, если массив ri пустой

        F[i] += np.sum(const * q**2 / (Ri**3)[:, np.newaxis] * ri, axis=0)

    return F

q = 6*4.8e-10
m = 12*9.1e-28
c = 3e10
K=100

Q=q
Ra_pc=(R-a)/100
Za_pc=-1.5*b
v=1.188e10

Energy = 480 /0.625*1e-12*1e3
std_dev_of_Energy = 1e-2 /0.625*1e-12*1e3

E=m*v**2/2*0.625*1e12*1e-3 #кэВ

print(np.sqrt(2*Energy/m))
print(v)
print(np.sqrt((2*std_dev_of_Energy/m)))
print((np.sqrt(2*Energy/m))/(np.sqrt((2*std_dev_of_Energy/m))))

E

#fj=2*pi/K
#f_mass=np.linspace(0,2*pi-fj,K)

alfa = 3
beta = 0.00245

x0=np.array([0.,0.,alfa*b])
X0=[]
for i in range(K):
  X0.append(x0)
X0=np.array(X0)

ix  = np.array([ [0.01,0.01,0.001] , [0.01,0.01,-0.001] ])
ix0 = np.array( [x0 , x0] )

Hg=H_full_parallel(Const, R, a, b, ix)+H_full_parallel(Const, R, a, b, ix-ix0)
print(beta*Hg)
print(LA.norm(beta*Hg,axis=1))

A = -b
B = (alfa+1)*b
C=2*R

def generation(mean,std_dev,lens,limitation,value_z,title):
  np.random.seed(42)

  points = []
  while len(points) < lens:
    x = np.random.normal(mean, std_dev)
    y = np.random.normal(mean, std_dev)
    z = value_z
    if x**2 + y**2 < limitation**2:
        points.append([x, y ,z])

  # Выводим первые несколько точек для проверки
  for i in range(4):
    print("Точка", i+1, ":", points[i])

  # Выводим общее количество точек
  formatted_limitation = "{:.0e}".format(limitation)  # Форматирование числа в формате "1e3"
  print("Всего сгенерировано", len(points), f"точек удовлетворяющих условию x^2 + y^2 < ({formatted_limitation})^2")
  points_array = np.array(points)

  # Строим график точек
  plt.scatter(points_array.T[0], points_array.T[1])
  plt.xlabel(title[0])
  plt.ylabel(title[1])
  plt.title(title[2])
  plt.show()
  return points

# @title Генерация координат
# Устанавливаем начальное состояние для воспроизводимости
state_x0=generation(mean=0,std_dev=Ra_pc,lens=K,limitation=Ra_pc,value_z=Za_pc,title=["x,cм","y,cм","Начальное положение точек"])

# @title Генерация скоростей
# Устанавливаем начальное состояние для воспроизводимости
state_v0=generation(mean=0,std_dev=np.sqrt(2*std_dev_of_Energy/m),lens=K,limitation=np.sqrt((2*std_dev_of_Energy/m)),value_z=np.sqrt(2*Energy/m),title=["vx ,cм/c","vy,cм/c","Начальные поперечные скорости точек"])

state = state_x0+state_v0


t_start=0.0   # Время старта    , с
t_end = 10e-9  # Время окончания , c
h = 1e-11     # Шаг интегрирования , c

n=K  # количество наблюдаемых предметов
text_mas=['coordinate, м',"speed, м/с ",n] # величины на графиках

"""Классовая реализация"""

#задание вычисляемой задачи
MyIDE_FunctionM = IDE_many_particuls_notnan(newFunction)


MyIDE_FunctionM.set_parameters(np.array(state), t_start, t_end, h,K)

# Проверка времени работы функции расчта времени работы
import time
start_time = time.time()

#расчёт ДифУравнения
X_enD,V_enD=MyIDE_FunctionM.calculete_parametrs()




end_time = time.time()
time=(end_time - start_time)
minuts_time = int(time / 60)
secunds_time = (time-minuts_time*60)

print("Время выполнения программы:", minuts_time ,"минут ",secunds_time , "секунд")

print(X_enD.shape)
plt.scatter(X_enD.T[0], X_enD.T[1])
plt.xlabel('x,см')
plt.ylabel('y,см')
plt.title('Конечное положение частиц')
plt.show()

print(V_enD.shape)
plt.scatter(V_enD.T[0], V_enD.T[1])
plt.xlabel('vx,см/c')
plt.ylabel('vy,см/c')
plt.title('Конечные поперечные скорости частиц')
plt.show()

# вывод результатов первые N и последние K каждого параметра ->  (N,K)
MyIDE_FunctionM.print_result(3,3)

MyIDE_FunctionM.plot_solution_2d(text_mas)

MyIDE_FunctionM.plot_solution_3d(text_mas)

{'newFunction': 495.8388373851776, 'newFunctionA': 339.20898699760437, 'newFunctionB': 241.12184405326843, 'newFunctionD': 250.1485402584076, 'newFunctionC': 493.1807897090912}

# @title 5000 x 5000
{'newFunction': 491.07299613952637, 'newFunctionA': 329.8079569339752, 'newFunctionB': 249.98084926605225, 'newFunctionD': 251.20530652999878, 'newFunctionC': 438.3170199394226}

# @title 1000 х 1000
{'newFunction': 519.1334908008575, 'newFunctionA': 288.3840172290802, 'newFunctionB': 256.6231143474579, 'newFunctionD': 242.06669759750366, 'newFunctionC': 404.4020562171936}

# @title 500 х 500
{'newFunction': 511.0702452659607, 'newFunctionA': 289.94442868232727, 'newFunctionB': 245.00401711463928, 'newFunctionD': 260.6311254501343, 'newFunctionC': 404.2630078792572}

#101 точка 6 частиц
{'newFunction': 0.443656444549560, 'newFunctionA': 0.226567983627319, 'newFunctionB': 0.28264164924621, 'newFunctionC': 0.327777385711669}
#1001 точка 6 частиц
{'newFunction': 4.605957984924316, 'newFunctionA': 2.242382287979126, 'newFunctionB': 2.57793927192688, 'newFunctionC': 4.161415338516235}
#10001 точка 6 частиц
{'newFunction': 47.89966821670532, 'newFunctionA': 23.71784019470215, 'newFunctionB': 27.3996238708496, 'newFunctionC': 34.21056127548218}

#101 точка 6 частиц
{'newFunction': 0.443656444549560, 'newFunctionA': 0.226567983627319, 'newFunctionB': 0.28264164924621, 'newFunctionC': 0.327777385711669}
#101 точка 100 частиц
{'newFunction': 5.278582572937012, 'newFunctionA': 3.093568325042724, 'newFunctionB': 0.07276391983032, 'newFunctionC': 5.943059206008911}

#1001 точка 6 частиц
{'newFunction': 4.605957984924316, 'newFunctionA': 2.242382287979126, 'newFunctionB': 2.57793927192688, 'newFunctionC': 4.161415338516235}
#1001 точка 16 частиц
{'newFunction': 11.51741170883178, 'newFunctionA': 5.639091730117798, 'newFunctionB': 3.58549165725708, 'newFunctionC': 8.528921365737915}
#1001 точка 100 частиц
{'newFunction': 61.85476517677307, 'newFunctionA': 31.81588816642761, 'newFunctionB': 0.227286815643310, 'newFunctionC': 55.1665968894958}

#10001 точка 6 частиц
{'newFunction': 47.89966821670532, 'newFunctionA': 23.71784019470215, 'newFunctionB': 27.3996238708496, 'newFunctionC': 34.21056127548218}
#10001 точка 16 частиц
{'newFunction': 121.0102257728576, 'newFunctionA': 49.85638928413391, 'newFunctionB': 38.5317323207855, 'newFunctionC': 82.51974296569824}

"""# Расчёт с помощью Scipy интеграторов"""

import numpy as np
from numba import jit, prange
from scipy.integrate import Radau, DOP853 , RK45 , RK23
import time as Time

@jit(parallel=True, fastmath=True,forceobj=True)
def equations(t, y):
    dydt = np.zeros_like(y)
    X = y.reshape(-1, 6)[:, :3]
    F = calculate_force(X,Q_new)

    for i in prange(num_pendulums):

        idx = i * 6
        idx3 = idx + 3

        x = y[idx:idx + 3]
        v = y[idx3:idx3 + 3]

        dxdt = v  # Положения маятников
        start_time = Time.time()

        #расчёт ДифУравнения
        H1 = H_simple_setka( x )
        H2 = H_simple_setka( x - x0 )


        gamma = 1/(1-LA.norm(v)**2/c**2)

        f = (q / m * np.cross(v/c, betta*(H1 + H2)) + F[i]/ m )
        dvdt = pr(f,v)/gamma + pl(f,v)/gamma**3
        #print(" ")
        #print("H",f-F[i]/m)
        #print(f"F[{i}]/m",F[i]/m)

        end_time = Time.time()
        time=(end_time - start_time)

        #print("расчёт поля:", time)


        dydt[idx:idx3]      = dxdt
        dydt[idx3:idx3 + 3] = dvdt

    return dydt

def pl(a, v):
    v_norm = np.linalg.norm(v)
    if v_norm == 0:
        raise ValueError("Vector v should not be zero")
    projection = (np.dot(a, v) / np.dot(v, v)) * v
    return projection

def pr(a, v):
    projection = pl(a, v)
    perpendicular = a - projection
    return perpendicular

# Класс, представляющий дифференциальное уравнение
class IDE_many_particuls_scipy:
    def __init__(self, Function,methood):
        self.Function = Function  # Функция, описывающая уравнение
        self.methood = methood

    # Задание параметров ДУ
    def set_parameters(self, state, t0, t_end, h , K):
        """
        Установка параметров для решения уравнения.

        Parameters:
        - state: Начальные условия
        - t_end: Время окончания
        - h: Шаг интегрирования
        """
        self.state = state
        self.t0 = t0
        self.t_end = t_end
        self.h = h
        self.k=K

    # Метод Рунге-Кутты 4 для расчёта ДУ
    @jit(parallel=True, fastmath=True,forceobj=True)
    def mhetood_calcul(self):

      solver = self.methood(self.Function, self.t0, self.state, self.t_end,self.h )

      # Списки для хранения траекторий маятников
      x = [[] for _ in range(self.k)]
      v = [[] for _ in range(self.k)]
      times = []

      # Интегрирование системы и сохранение траекторий
      while solver.status == 'running':
         t = solver.t
         y = solver.y
         times.append(t)
         for i in range(self.k):
            idx = i * 6
            idx3=idx+3
            x[i].append(y[idx:idx + 3].copy())
            v[i].append(y[idx3:idx3 + 3].copy())
         solver.step()

      # Преобразуем список списков в массив numpy для удобства использования
      x = np.array(x)
      v = np.array(v)
      times = np.array(times)

      return times, x,v  # Преобразуем список в массив для совместимости с остальным кодом

    # Расчёт ДУ
    @jit(parallel=True, fastmath=True,forceobj=True)
    def calculete_parametrs(self):
        time_points, x ,v = self.mhetood_calcul()
        self.x = x
        self.v = v

        self.time_points = time_points
        # Создание маски, содержащей значения True для векторов, не содержащих NaN



        print(self.x.shape)
        print("начальные параметры")
        print("X = ",np.transpose(self.x, (1, 0, 2))[0])
        print("V = ",np.transpose(self.v, (1, 0, 2))[0])

        print("конечные параметры")
        print("X = ",np.transpose(self.x, (1, 0, 2))[-1])
        print("V = ",np.transpose(self.v, (1, 0, 2))[-1])

        return np.transpose(self.x, (1, 0, 2))[-1],\
               np.transpose(self.v, (1, 0, 2))[-1]

    # Вывод результатов расчёта
    def print_result(self,N,K):
      X = self.x
      V = self.v



      for i in range(self.k):
        print("------------------------------------------")
        print(f"Координаты и скорости {i+1}-ой частицы ")
        x=X[i]
        v=V[i]
        print(x.shape)
        print(v.shape)
        for j in range(3):
          print(f"{j+1}-ая компонента координаты")
          print(x.T[j])
          print(" ")
          print(f"{j+1}-ая компонента скорости")
          print(v.T[j])
          print(" ")
        print("  ")
        print("  ")

    # Функция отображения компонент поля
    def plot_solution_2d(self, text_mas):
      x = np.transpose(self.x, (2, 0, 1))
      v = np.transpose(self.v, (2, 0, 1))
      print(x.shape)
      print(v.shape)

      def mins(x):
        if len(x)>0:
          return min(x)
        else:
          return -1

      def solenoid(fig):
        fig.add_trace(go.Scatter(x=T_00, y=R_sol, mode='lines', name="начало первого", line=dict(color="black")))
        fig.add_trace(go.Scatter(x=T_01, y=R_sol, mode='lines', name="конец первого",  line=dict(color="black")))
        fig.add_trace(go.Scatter(x=T_10, y=R_sol, mode='lines', name="начало второго", line=dict(color="black")))
        fig.add_trace(go.Scatter(x=T_11, y=R_sol, mode='lines', name="конец второго",  line=dict(color="black")))




      time_0s = self.time_points[  mins( np.where(self.x[:, :, 2] > -b)[1])       ]
      time_0e = self.time_points[  mins( np.where(self.x[:, :, 2] > b)[1])        ]
      time_1s = self.time_points[  mins( np.where(self.x[:, :, 2] > alfa*b-b)[1]) ]
      time_1e = self.time_points[  mins( np.where(self.x[:, :, 2] > alfa*b+b)[1]) ]

      T_00=[time_0s,time_0s]
      T_01=[time_0e,time_0e]
      T_10=[time_1s,time_1s]
      T_11=[time_1e,time_1e]

      R_sol=[-R+a,+R-a]

      def j(x):
        if len(x)>0:
          return min(x)
        else:
          return 0

      def solenoid(fig):
        fig.add_trace(go.Scatter(x=T_00, y=R_sol, mode='lines', name="начало первого", line=dict(color="black")))
        fig.add_trace(go.Scatter(x=T_01, y=R_sol, mode='lines', name="конец первого",  line=dict(color="black")))
        fig.add_trace(go.Scatter(x=T_10, y=R_sol, mode='lines', name="начало второго", line=dict(color="black")))
        fig.add_trace(go.Scatter(x=T_11, y=R_sol, mode='lines', name="конец второго",  line=dict(color="black")))



      for k in range(3):
        print(x[k].shape)
        figx = make_subplots(rows=1, cols=1)
        for i in range(self.k):
            figx.add_trace(go.Scatter(x=self.time_points, y=x[k][i], mode='lines', name=f"R{k+1} {i+1}"))

        solenoid(figx)

        self.plt_markers_P(k, figx,"координата")
        figx.update_layout(title_text='Interactive 2D Solution Plot', showlegend=False)

        fig = make_subplots(rows=1, cols=1)
        for i in range(self.k):
            fig.add_trace(go.Scatter(x=self.time_points, y=v[k][i], mode='lines', name=f"V{k+1} {i+1}"))

        #solenoid(fig)
        self.plt_markers_P(k, fig,"скорость")
        fig.update_layout(title_text='Interactive 2D Solution Plot', showlegend=False)


        Fig = make_subplots(rows=1, cols=1)
        for i in range(self.k):
            Fig.add_trace(go.Scatter(x=x[k][i], y=v[k][i], mode='lines', name=f' v/x-{i+1}'))

        self.plt_markers_F(k, Fig)
        Fig.update_layout(title_text='Interactive 2D Solution Plot', showlegend=False)
      figx1 = make_subplots(rows=1, cols=1)
      for j in range(self.k):
        figx1.add_trace(go.Scatter(x=self.time_points, y=LA.norm(self.v[j],axis=1), mode='lines', name=f"V{j}"))
      print(f'-----------------///---------------')
      print(f'  ')
      print(f'-----------------///---------------')
      figx1.update_layout(xaxis_title='время', yaxis_title="модуль скорости")
      figx1.update_layout(title=f'Зависимость от времени модуля скорости')

      figx1.update_layout(legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
      figx1.show()
      figx1.update_layout(title_text='ytyt', showlegend=False)


    # Функция отображения графика в пространстве
    def plot_solution_3d(self, text_mas):
      fig = make_subplots(rows=1, cols=1, specs=[[{'type': 'scatter3d'}]])
      x = np.transpose(self.x, (0, 2, 1))
      v = np.transpose(self.v, (0, 2, 1))
      for i in range(self.k):
        fig.add_trace(go.Scatter3d(x=x[i][0], y=x[i][1], z=x[i][2], mode='lines'))
      fig.update_layout(scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z'), scene_aspectmode='cube')
      fig.update_layout(title_text='Траектория', showlegend=False)
      fig.show()
      fig = make_subplots(rows=1, cols=1, specs=[[{'type': 'scatter3d'}]])
      for i in range(self.k):
        fig.add_trace(go.Scatter3d(x=v[i][0], y=v[i][1], z=v[i][2], mode='lines'))
      fig.update_layout(scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z'), scene_aspectmode='cube')
      fig.update_layout(title_text='Скорость', showlegend=False)
      fig.show()

    # оформление графика величин от времени
    def plt_markers_P(self, k, fig ,text):
       print(f'-----------------///---------------')
       print(f'  ')
       print(f'-----------------///---------------')
       fig.update_layout(xaxis_title='время', yaxis_title=text)
       fig.update_layout(title=f'Зависимость от времени {k+1}-ой {text}')

       fig.update_layout(legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
       fig.show()

    # оформление фазового портрета
    def plt_markers_F(self, k, fig):

      fig.update_layout(xaxis_title='координата', yaxis_title='скорость')
      fig.update_layout(title=f'Фазовый портрет {k+1}-ой координаты')

      fig.update_layout(legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
      fig.show()

Zb_pc = -1.5*b
Rb_pc = (R-a)/90

q = 6*4.8e-10
m = 12*9.1e-28
c = 3e10
num_pendulums = 125

Q_new = q
betta=0.037

v=1.188e10

Energy_b = 480 /0.625*1e-12*1e3
std_dev_of_Energy_b = 1e-2 /0.625*1e-12*1e3

# @title Генерация координат
# Устанавливаем начальное состояние для воспроизводимости
state_x0=generation(mean=0,std_dev=Rb_pc,lens=num_pendulums,limitation=Rb_pc,value_z=Zb_pc,title=["x,cм","y,см","начальные положения частиц"])

# @title Генерация скоростей
# Устанавливаем начальное состояние для воспроизводимости
state_v0=generation(mean=0,std_dev=np.sqrt(2*std_dev_of_Energy_b/m),lens=num_pendulums,limitation=np.sqrt((2*std_dev_of_Energy_b/m)),value_z=np.sqrt(2*Energy_b/m),title=["vx,cм/c","vy,см/c","поперечные начальные скорости частиц"])

# Исходный двумерный список

y0 = [[]*6*num_pendulums]
# Вывод результата
for i in range(num_pendulums):
  idx = 6*i
  y0[idx:idx+6]=state_x0[i]+state_v0[i]



y0=np.array(y0)
print(y0.shape)

#print(y0)

t0 = 0.0
t_bound =  15e-9  # Время окончания , c
max_step = 2.5e-11

#задание вычисляемой задачи
MyIDE_FunctionE = IDE_many_particuls_scipy(equations,RK45)


MyIDE_FunctionE.set_parameters(y0, t0, t_bound, max_step,num_pendulums)

# Проверка времени работы функции расчта времени работы
import time
start_time = time.time()

#расчёт ДифУравнения
X_end,V_end=MyIDE_FunctionE.calculete_parametrs()


end_time = time.time()
time=(end_time - start_time)
minuts_time = int(time / 60)
secunds_time = (time-minuts_time*60)

print("Время выполнения программы:", minuts_time ,"минут ",secunds_time , "секунд")

print(X_end.shape)
plt.scatter(X_end.T[0], X_end.T[1])
plt.xlabel('x,cм')
plt.ylabel('y,см')
plt.title('Конечное положение частиц')
plt.show()

print(V_end.shape)
plt.scatter(V_end.T[0], V_end.T[1])
plt.xlabel('vx,см/c')
plt.ylabel('vy,см/c')
plt.title('Конечные поперечные скорости ')
plt.show()

# вывод результатов первые N и последние K каждого параметра ->  (N,K)
MyIDE_FunctionE.print_result(3,3)

MyIDE_FunctionE.plot_solution_2d(text_mas)

MyIDE_FunctionE.plot_solution_3d(text_mas)

"""# Новый раздел"""

Z_mas=np.linspace(-1.8*b,1.8*b+(alfa+1)*b,10000)
R_mas=np.linspace(0,R-a*1.0001,10000)

Ri=(R-a)/100
f=-np.pi/4

Hk=[]
for Z in Z_mas:
  vec=np.array([Ri*np.cos(f),Ri*np.sin(f),Z])
  Hk.append( H_simple_setka(vec) + H_simple_setka(vec-x0) )

Hkx=np.array(Hk).T[0].tolist()
Hky=np.array(Hk).T[1].tolist()
Hkz=np.array(Hk).T[2].tolist()

plt.figure(figsize=(10, 6))
plt.plot(Z_mas, Hkx)
plt.xlabel('Z,см')
plt.ylabel('Hx,Гс')
plt.title('')
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 6))
plt.plot(Z_mas, Hky)
plt.xlabel('Z')
plt.ylabel('H')
plt.title('')
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 6))
plt.plot(Z_mas, Hkz)
plt.xlabel('Z')
plt.ylabel('H')
plt.title('')
plt.grid(True)
plt.show()

Zi = -210

Hk=[]
for Ri in R_mas:
  vec=np.array([Ri*np.cos(f),Ri*np.sin(f),Zi])
  Hk.append( H_simple_setka(vec) + H_simple_setka(vec-x0) )

Hkx=np.array(Hk).T[0].tolist()
Hky=np.array(Hk).T[1].tolist()
Hkz=np.array(Hk).T[2].tolist()

plt.figure(figsize=(10, 6))
plt.plot(R_mas, Hkx)
plt.xlabel('Z')
plt.ylabel('H')
plt.title('')
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 6))
plt.plot(R_mas, Hky)
plt.xlabel('Z')
plt.ylabel('H')
plt.title('')
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 6))
plt.plot(R_mas, Hkz)
plt.xlabel('Z')
plt.ylabel('H')
plt.title('')
plt.grid(True)
plt.show()